package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal PROG, CONST, VOID, IF, ELSE, BREAK, CONTINUE, RETURN, READ, PRINT, SWITCH, CASE, ENUM, FOR, LENGTH, NEW;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOTEQUAL, GRT, GRTEQ, LS, LSEQ, AND, OR, INC, DEC, ASSIGN, SEMI, DOT, COL, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, QMARK;

terminal Integer NUMBER, BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program Program;
nonterminal 
			ProgramName ProgramName;
nonterminal
			ConVarDecList ConVarDecList;
nonterminal
			ConDecList ConDecList;
nonterminal
			VarDeclList VarDeclList;
nonterminal
			ConDecl ConDecl;
nonterminal
			Constant Constant;
nonterminal
			MethodDeclList MethodDeclList;
nonterminal 
			ConDeclMore ConDeclMore;
nonterminal 
			VarDecl VarDecl;
nonterminal 
			VarDeclMore VarDeclMore;
nonterminal
			MethodDecl MethodDecl;
nonterminal
			FormParList FormParList;
nonterminal
			FormParMore FormParMore;
nonterminal
			FormPar FormPar;
nonterminal
			VarDeclListRec VarDeclListRec;
nonterminal
			EnumDeclList EnumDeclList;
nonterminal
			EnumList EnumList;
nonterminal
			EnumItem EnumItem;
nonterminal
			StatementList StatementList;
nonterminal
			Statement Statement;
nonterminal 
			DesignatorStatement DesignatorStatement;
nonterminal  
			Relop Relop;
nonterminal
			Assignop Assignop;
nonterminal
			Mulop Mulop;
nonterminal
			Addop Addop;
nonterminal
			ActPars ActPars;
nonterminal
			Unary Unary;
nonterminal			
			CaseStatements CaseStatements;
nonterminal
			CaseList CaseList;
nonterminal
			Case Case;
nonterminal
			ForDesignatorStatement ForDesignatorStatement;
nonterminal
			ForCondition ForCondition;
nonterminal
			ForStep ForStep;
nonterminal
			MatchedStatement MatchedStatement;
nonterminal
			UnmatchedStatement UnmatchedStatement;
nonterminal
			EnumName EnumName;
nonterminal
			ForStart ForStart;
nonterminal
			SwitchStart SwitchStart;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTerm, CondFact, Factor, FactorUnar, FactorList, TermList, Term, Expr, Type, TernaryCondition, TernExpr1, TernExpr2, IfCondition;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, DesignatorArrayName, MethRetAndName;


Program ::= (Program) PROG ProgramName:P1 ConVarDecList:C2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(P1, C2, M3); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:I1 {: RESULT=new ProgramName(I1); RESULT.setLine(I1left); :};

ConVarDecList ::= 	(ConVarDecList_con) ConDecList:C1 ConVarDecList:C2 {: RESULT=new ConVarDecList_con(C1, C2); RESULT.setLine(C1left); :}
					|
					(ConVarDecList_var) VarDeclList:V1 ConVarDecList:C2 {: RESULT=new ConVarDecList_var(V1, C2); RESULT.setLine(V1left); :}
					|
					(ConVarDecList_enum) EnumDeclList:E1 ConVarDecList:C2 {: RESULT=new ConVarDecList_enum(E1, C2); RESULT.setLine(E1left); :}
					|
					(ConVarDecList_e) {: RESULT=new ConVarDecList_e(); :} /* epsilon */
					;
					
/* ENUM */

EnumDeclList ::= (EnumDeclList) ENUM EnumName:E1 LBRACE EnumList:E2 RBRACE {: RESULT=new EnumDeclList(E1, E2); RESULT.setLine(E1left); :} ;

EnumName ::= (EnumName) IDENT:I1 {: RESULT=new EnumName(I1); RESULT.setLine(I1left); :};

EnumList ::= (EnumList_comma) EnumList:E1 COMMA EnumItem:E2 {: RESULT=new EnumList_comma(E1, E2); RESULT.setLine(E1left); :}
			| 
			(EnumList_item) EnumItem:E1 {: RESULT=new EnumList_item(E1); RESULT.setLine(E1left); :}
			;

EnumItem ::= (EnumItem_var) IDENT:I1 {: RESULT=new EnumItem_var(I1); RESULT.setLine(I1left); :}
           | 
		   (EnumItem_ass) IDENT:I1 ASSIGN NUMBER:N2 {: RESULT=new EnumItem_ass(I1, N2); RESULT.setLine(I1left); :}
           ;
				
/* CONST */

ConDecList ::= (ConDecList_l) CONST Type:T1 ConDecl:C2 ConDeclMore:C3 SEMI {: RESULT=new ConDecList_l(T1, C2, C3); RESULT.setLine(T1left); :}
				| (ConDeclList_error) error :e 
				{: parser.report_error("Izvrsen oporavak do ; u liniji " + eleft, null); :} {: RESULT=new ConDeclList_error(); :}
				;

ConDecl ::= (ConDecl) IDENT:I1 ASSIGN Constant:C2 {: RESULT=new ConDecl(I1, C2); RESULT.setLine(I1left); :};

ConDeclMore ::= (ConDeclMore_comma) COMMA ConDecl:C1 ConDeclMore:C2 {: RESULT=new ConDeclMore_comma(C1, C2); RESULT.setLine(C1left); :}
				|
				(ConDeclMore_e) {: RESULT=new ConDeclMore_e(); :} /* epsilon */
				| (MoreConstError) error COMMA:e 
				{: parser.report_error("Izvrsen oporavak do , u liniji " + eleft, null); :} {: RESULT=new MoreConstError(); :}
				;

Constant ::= 	(Constant_n) NUMBER:N1 {: RESULT=new Constant_n(N1); RESULT.setLine(N1left); :}
				|
				(Constant_c) CHAR:C1 {: RESULT=new Constant_c(C1); RESULT.setLine(C1left); :}
				|
				(Constant_b) BOOL:B1 {: RESULT=new Constant_b(B1); RESULT.setLine(B1left); :}
				;

/* VAR */

VarDeclList ::= (VarDeclList) Type:T1 VarDecl:V2 VarDeclMore:V3 SEMI {: RESULT=new VarDeclList(T1, V2, V3); RESULT.setLine(T1left); :} ;


VarDecl ::= (VarDecl_var) IDENT:I1 {: RESULT=new VarDecl_var(I1); RESULT.setLine(I1left); :}  
			|
			(VarDecl_array) IDENT:I1 LBRACKET RBRACKET {: RESULT=new VarDecl_array(I1); RESULT.setLine(I1left); :}
			; 


VarDeclMore ::= (VarDeclMore_comma) COMMA VarDecl:V1 VarDeclMore:V2 {: RESULT=new VarDeclMore_comma(V1, V2); RESULT.setLine(V1left); :} 
				|
				(VarDeclMore_e) {: RESULT=new VarDeclMore_e(); :}
				; 

Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};


/* METHOD */

MethodDeclList ::= 	(MethodDeclList_rec) MethodDeclList:M1  MethodDecl:M2 {: RESULT=new MethodDeclList_rec(M1, M2); RESULT.setLine(M1left); :}
					|
					(MethodDeclList_e) {: RESULT=new MethodDeclList_e(); :}
					;

MethodDecl ::= (MethodDecl) MethRetAndName:M1 LPAREN FormParList:F2 RPAREN VarDeclListRec:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(M1, F2, V3, S4); RESULT.setLine(M1left); :};

MethRetAndName ::= (MethRetAndName_type) Type:T1 IDENT:I2 {: RESULT=new MethRetAndName_type(T1, I2); RESULT.setLine(T1left); :}
					  |
					(MethRetAndName_void) VOID IDENT:I1 {: RESULT=new MethRetAndName_void(I1); RESULT.setLine(I1left); :}
					;


FormParList ::= (FormParList_rec) FormPar:F1 FormParMore:F2 {: RESULT=new FormParList_rec(F1, F2); RESULT.setLine(F1left); :}
				|
				(FormParList_e) {: RESULT=new FormParList_e(); :}
				;

FormParMore ::= (FormParMore_comma) COMMA FormPar:F1 FormParMore:F2 {: RESULT=new FormParMore_comma(F1, F2); RESULT.setLine(F1left); :}
                |
				(FormParMore_e) {: RESULT=new FormParMore_e(); :} 
				;

FormPar ::= (FormPar_var) Type:T1 IDENT:I2 {: RESULT=new FormPar_var(T1, I2); RESULT.setLine(T1left); :}
		   |
		   (FormPar_array) Type:T1 IDENT:I2 LBRACKET RBRACKET {: RESULT=new FormPar_array(T1, I2); RESULT.setLine(T1left); :}
		   ;	

VarDeclListRec ::= 	(VarDeclListRec_rec) VarDeclListRec:V1 VarDeclList:V2 {: RESULT=new VarDeclListRec_rec(V1, V2); RESULT.setLine(V1left); :}
					|
					(VarDeclListRec_e) {: RESULT=new VarDeclListRec_e(); :} /* epsilon */
					;

/* STATEMENT */

StatementList ::= 	(StatementList_rec) StatementList:S1 Statement:S2 {: RESULT=new StatementList_rec(S1, S2); RESULT.setLine(S1left); :}
				   	|										   
				  	(StatementList_e) {: RESULT=new StatementList_e(); :} /* epsilon */
				   	;

Statement ::= (MatchedStat) MatchedStatement:M1 {: RESULT=new MatchedStat(M1); RESULT.setLine(M1left); :}
			  |
			  (UnmatchedStat) UnmatchedStatement:U1 {: RESULT=new UnmatchedStat(U1); RESULT.setLine(U1left); :}
			  ;
			   
MatchedStatement ::=  (DesignStatement) DesignatorStatement:D1 SEMI {: RESULT=new DesignStatement(D1); RESULT.setLine(D1left); :}
					  |
					  (IfElseStatement) IF LPAREN IfCondition:I1 RPAREN MatchedStatement:M2 ELSE MatchedStatement:M3 {: RESULT=new IfElseStatement(I1, M2, M3); RESULT.setLine(I1left); :}
					  |
					  (BreakStatement) BREAK SEMI {: RESULT=new BreakStatement(); :}
					  |
					  (ContinueStatement) CONTINUE SEMI {: RESULT=new ContinueStatement(); :}
					  |
					  (ReturnStatement_expr) RETURN Expr:E1 SEMI {: RESULT=new ReturnStatement_expr(E1); RESULT.setLine(E1left); :}
					  |
					  (ReturnStatement_noexpr) RETURN SEMI {: RESULT=new ReturnStatement_noexpr(); :}
					  |
					  (ReadStatement) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
					  |
					  (PrintStatement) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new PrintStatement(E1); RESULT.setLine(E1left); :}
					  |
					  (PrintStatement2) PRINT LPAREN Expr:E1 COMMA NUMBER:N2 RPAREN SEMI {: RESULT=new PrintStatement2(E1, N2); RESULT.setLine(E1left); :}
			  		  |
					  (SwitchStatement) SwitchStart:S1 LBRACE CaseList:C2 RBRACE {: RESULT=new SwitchStatement(S1, C2); RESULT.setLine(S1left); :}
					  |
					  (ForStatement) ForStart:F1 LPAREN  ForDesignatorStatement:F2 SEMI ForCondition:F3 SEMI ForStep:F4  RPAREN MatchedStatement:M5 {: RESULT=new ForStatement(F1, F2, F3, F4, M5); RESULT.setLine(F1left); :}
					  |
					  (RecStatement) LBRACE StatementList:S1 RBRACE {: RESULT=new RecStatement(S1); RESULT.setLine(S1left); :}
					  ;

UnmatchedStatement ::= (IfElseStatement_non_else) IF LPAREN IfCondition:I1 RPAREN Statement:S2 {: RESULT=new IfElseStatement_non_else(I1, S2); RESULT.setLine(I1left); :}
					   |
					   (IfElseStatement_else) IF LPAREN IfCondition:I1 RPAREN MatchedStatement:M2 ELSE UnmatchedStatement:U3 {: RESULT=new IfElseStatement_else(I1, M2, U3); RESULT.setLine(I1left); :}
					   ;
					   
IfCondition ::= (IfCondition) Condition:C1 {: RESULT=new IfCondition(C1); RESULT.setLine(C1left); :};


ForStart ::= (ForStart) FOR {: RESULT=new ForStart(); :};

ForStep ::= (ForStep_step) DesignatorStatement:D1 {: RESULT=new ForStep_step(D1); RESULT.setLine(D1left); :}
           |
		   (ForStep_e) {: RESULT=new ForStep_e(); :} /* epsilon */
		   ; 

SwitchStart ::= (SwitchStart) SWITCH LPAREN Expr:E1 RPAREN {: RESULT=new SwitchStart(E1); RESULT.setLine(E1left); :};

ForDesignatorStatement ::= (ForDesignatorStatement_for) DesignatorStatement:D1 {: RESULT=new ForDesignatorStatement_for(D1); RESULT.setLine(D1left); :}
                           |
						   (ForDesignatorStatement_e) {: RESULT=new ForDesignatorStatement_e(); :} /* epsilon */
						   ; 

ForCondition ::= (ForCondition_for) Condition:C1 {: RESULT=new ForCondition_for(C1); RESULT.setLine(C1left); :}
				|
				(ForCondition_e) {: RESULT=new ForCondition_e(); :} /* epsilon */
				; 

CaseList ::= (CaseList_list) CaseList:C1 Case:C2 {: RESULT=new CaseList_list(C1, C2); RESULT.setLine(C1left); :}
           | (CaseList_e) {: RESULT=new CaseList_e(); :} /* epsilon */
           ;

Case ::= (Case) CASE NUMBER:N1 COL CaseStatements:C2 {: RESULT=new Case(N1, C2); RESULT.setLine(N1left); :};

CaseStatements ::= (CaseStatements_state) CaseStatements:C1 Statement:S2 {: RESULT=new CaseStatements_state(C1, S2); RESULT.setLine(C1left); :}
                    |
				   (CaseStatements_e) {: RESULT=new CaseStatements_e(); :} /* epsilon */ 
				   ;

ActPars ::= (ActPars_list) ActPars:A1 COMMA Expr:E2 {: RESULT=new ActPars_list(A1, E2); RESULT.setLine(A1left); :}
            |
			(ActPars_single) Expr:E1 {: RESULT=new ActPars_single(E1); RESULT.setLine(E1left); :}
			;

DesignatorStatement ::= (DesignatorStatement_ass) Designator:D1 Assignop:A2 Expr:E3 {: RESULT=new DesignatorStatement_ass(D1, A2, E3); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_actpar) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesignatorStatement_actpar(D1, A2); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_noactpar) Designator:D1 LPAREN RPAREN {: RESULT=new DesignatorStatement_noactpar(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_inc) Designator:D1 INC {: RESULT=new DesignatorStatement_inc(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_dec) Designator:D1 DEC {: RESULT=new DesignatorStatement_dec(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatement_error) error:e 
						{: parser.report_error("Oporavak od greske u DesSttmnt.Linija: "+eleft,null); :} {: RESULT=new DesignatorStatement_error(); :}
						;

/* CONDITION */

Condition ::= (ConditionList) Condition:C1 OR CondTerm:C2 {: RESULT=new ConditionList(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (SingleCondition) CondTerm:C1 {: RESULT=new SingleCondition(C1); RESULT.setLine(C1left); :}	
				;

CondTerm ::= (CondTermList) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondTermList(C1, C2); RESULT.setLine(C1left); :}
             |
			 (SingleCondTerm) CondFact:C1 {: RESULT=new SingleCondTerm(C1); RESULT.setLine(C1left); :}
			 ;
			 
CondFact ::= (CondFact_norelop) TermList:T1 {: RESULT=new CondFact_norelop(T1); RESULT.setLine(T1left); :}    /* MOZDA TREBA Expr */
             |
             (CondFact_relop) TermList:T1 Relop:R2 TermList:T3 {: RESULT=new CondFact_relop(T1, R2, T3); RESULT.setLine(T1left); :}
             ;

Expr ::= (Expr_notern) TermList:T1 {: RESULT=new Expr_notern(T1); RESULT.setLine(T1left); :}
		 |
	     (Expr_tern) TernaryCondition:T1 QMARK TernExpr1:T2 COL TernExpr2:T3 {: RESULT=new Expr_tern(T1, T2, T3); RESULT.setLine(T1left); :}
		  ;

TernaryCondition ::= (TernaryCondition)Condition:C1 {: RESULT=new TernaryCondition(C1); RESULT.setLine(C1left); :};

TernExpr1 ::= (TernExpr1) Expr:E1 {: RESULT=new TernExpr1(E1); RESULT.setLine(E1left); :};

TernExpr2 ::= (TernExpr2) Expr:E1 {: RESULT=new TernExpr2(E1); RESULT.setLine(E1left); :};

TermList ::= (TermList_addop) TermList:T1 Addop:A2 Term:T3 {: RESULT=new TermList_addop(T1, A2, T3); RESULT.setLine(T1left); :}
             |
			 (SingleTerm) Term:T1 {: RESULT=new SingleTerm(T1); RESULT.setLine(T1left); :}
			 ;

Term ::= (Term) FactorList:F1 {: RESULT=new Term(F1); RESULT.setLine(F1left); :};

FactorList ::= (FactorList_mulop) FactorList:F1 Mulop:M2 Factor:F3 {: RESULT=new FactorList_mulop(F1, M2, F3); RESULT.setLine(F1left); :}
               |
			   (SingleFactor) Factor:F1 {: RESULT=new SingleFactor(F1); RESULT.setLine(F1left); :}
			   ;

Factor ::= (Factor) Unary:U1 FactorUnar:F2 {: RESULT=new Factor(U1, F2); RESULT.setLine(U1left); :};

Unary ::= 	(Unary_m) MINUS {: RESULT=new Unary_m(); :}
			|
			(Unary_e) {: RESULT=new Unary_e(); :} /* epsilon */
			;

FactorUnar ::=  (Factor_des) Designator:D1 {: RESULT=new Factor_des(D1); RESULT.setLine(D1left); :}
				|
				(Factor_methpars) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new Factor_methpars(D1, A2); RESULT.setLine(D1left); :}
		   		|
				(Factor_methnopars) Designator:D1 LPAREN  RPAREN {: RESULT=new Factor_methnopars(D1); RESULT.setLine(D1left); :}
		   		|
		   		(Factor_n) NUMBER:N1 {: RESULT=new Factor_n(N1); RESULT.setLine(N1left); :}
		   		|
		   		(Factor_c) CHAR:C1 {: RESULT=new Factor_c(C1); RESULT.setLine(C1left); :}
		   		|
		   		(Factor_b) BOOL:B1 {: RESULT=new Factor_b(B1); RESULT.setLine(B1left); :}
		   		|		   
		   		(Factor_new_array) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new Factor_new_array(T1, E2); RESULT.setLine(T1left); :}
		   		|
		   		(Factor_expr) LPAREN Expr:E1 RPAREN {: RESULT=new Factor_expr(E1); RESULT.setLine(E1left); :}
		   		;

Designator ::= (Designator_var) IDENT:I1 {: RESULT=new Designator_var(I1); RESULT.setLine(I1left); :} 
               |
			   (Designator_enum) IDENT:I1 DOT IDENT:I2 {: RESULT=new Designator_enum(I1, I2); RESULT.setLine(I1left); :}
			   |
			   (Designator_len) IDENT:I1 DOT LENGTH {: RESULT=new Designator_len(I1); RESULT.setLine(I1left); :}
			   |
			   (Designator_elem) DesignatorArrayName:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new Designator_elem(D1, E2); RESULT.setLine(D1left); :}
			   ;
			   
DesignatorArrayName ::= (DesignatorArrayName) IDENT:I1 {: RESULT=new DesignatorArrayName(I1); RESULT.setLine(I1left); :};
	
			  
Relop ::= (Relop_eq) EQUAL {: RESULT=new Relop_eq(); :}
          |
		  (Relop_neq) NOTEQUAL {: RESULT=new Relop_neq(); :}
          |
		  (Relop_grt) GRT {: RESULT=new Relop_grt(); :}
          |
		  (Relop_Geq) GRTEQ {: RESULT=new Relop_Geq(); :}
          |
		  (Relop_ls) LS {: RESULT=new Relop_ls(); :}
          |
		  (Relop_leq) LSEQ {: RESULT=new Relop_leq(); :}
          ;

Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Addop ::= (Addop_plus) PLUS {: RESULT=new Addop_plus(); :} | (Addop_minus) MINUS {: RESULT=new Addop_minus(); :} ;

Mulop ::= (Mulop_mul) MUL {: RESULT=new Mulop_mul(); :} | (Mulop_div) DIV {: RESULT=new Mulop_div(); :} | (Mulop_mod) MOD {: RESULT=new Mulop_mod(); :};