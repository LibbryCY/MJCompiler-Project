package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal PROG, CONST, VOID, IF, ELSE, BREAK, CONTINUE, RETURN, READ, PRINT, SWITCH, CASE, ENUM, FOR, LENGTH, NEW;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOTEQUAL, GRT, GRTEQ, LS, LSEQ, AND, OR, INC, DEC, ASSIGN, SEMI, DOT, COL, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, QMARK;

terminal Integer NUMBER, BOOL;
terminal Character CHAR;
terminal String IDENT;

nonterminal Program, 
			ProgramName,
			ConVarDecList,
			ConDecList,
			VarDeclList,
			ConDecl,
			Constant,
			MethodDeclList, 
			ConDeclMore, 
			VarDecl, 
			VarDeclMore,
			MethodDecl,
			FormParList,
			FormParMore,
			FormPar,
			VarDeclListRec,
			EnumDeclList,
			EnumList,
			EnumItem,
			StatementList,
			Statement, 
			DesignatorStatement,  
			Relop,
			Assignop,
			Mulop,
			Addop,
			ActPars,
			Unary,			
			CaseStatements,
			CaseList,
			Case,
			ForDesignatorStatement,
			ForCondition,
			MatchedStatement,
			UnmatchedStatement,
			EnumName,
			ForStart,
			SwitchStart;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTerm, CondFact, Factor, FactorUnar, FactorList, TermList, Term, Expr, Type, TernaryCondition, TernExpr1, TernExpr2;
nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, DesignatorArrayName, MethRetAndName;


Program ::= (Program) PROG ProgramName ConVarDecList LBRACE MethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT;

ConVarDecList ::= 	(ConVarDecList_con) ConDecList ConVarDecList
					|
					(ConVarDecList_var) VarDeclList ConVarDecList
					|
					(ConVarDecList_enum) EnumDeclList ConVarDecList
					|
					(ConVarDecList_e) /* epsilon */
					;
					
/* ENUM */

EnumDeclList ::= (EnumDeclList) ENUM EnumName LBRACE EnumList RBRACE ;

EnumName ::= (EnumName) IDENT;

EnumList ::= (EnumList_comma) EnumList COMMA EnumItem
			| 
			(EnumList_item) EnumItem
			;

EnumItem ::= (EnumItem_var) IDENT
           | 
		   (EnumItem_ass) IDENT ASSIGN NUMBER
           ;
				
/* CONST */

ConDecList ::= (ConDecList_l) CONST Type ConDecl ConDeclMore SEMI
				| (ConDeclList_error) error :e 
				{: parser.report_error("Izvrsen oporavak do ; u liniji " + eleft, null); :}
				;

ConDecl ::= (ConDecl) IDENT ASSIGN Constant;

ConDeclMore ::= (ConDeclMore_comma) COMMA ConDecl ConDeclMore
				|
				(ConDeclMore_e) /* epsilon */
				| (MoreConstError) error COMMA:e 
				{: parser.report_error("Izvrsen oporavak do , u liniji " + eleft, null); :}
				;

Constant ::= 	(Constant_n) NUMBER
				|
				(Constant_c) CHAR
				|
				(Constant_b) BOOL
				;

/* VAR */

VarDeclList ::= (VarDeclList) Type VarDecl VarDeclMore SEMI ;


VarDecl ::= (VarDecl_var) IDENT  
			|
			(VarDecl_array) IDENT LBRACKET RBRACKET
			; 


VarDeclMore ::= (VarDeclMore_comma) COMMA VarDecl VarDeclMore 
				|
				(VarDeclMore_e)
				; 

Type ::= (Type) IDENT;


/* METHOD */

MethodDeclList ::= 	(MethodDeclList_rec) MethodDeclList  MethodDecl
					|
					(MethodDeclList_e)
					;

MethodDecl ::= (MethodDecl) MethRetAndName LPAREN FormParList RPAREN VarDeclListRec LBRACE StatementList RBRACE;

MethRetAndName ::= (MethRetAndName_type) Type IDENT
					  |
					(MethRetAndName_void) VOID IDENT
					;


FormParList ::= (FormParList_rec) FormPar FormParMore
				|
				(FormParList_e)
				;

FormParMore ::= (FormParMore_comma) COMMA FormPar FormParMore
                |
				(FormParMore_e) 
				;

FormPar ::= (FormPar_var) Type IDENT
		   |
		   (FormPar_array) Type IDENT LBRACKET RBRACKET
		   ;	

VarDeclListRec ::= 	(VarDeclListRec_rec) VarDeclListRec VarDeclList
					|
					(VarDeclListRec_e) /* epsilon */
					;

/* STATEMENT */

StatementList ::= 	(StatementList_rec) StatementList Statement
				   	|										   
				  	(StatementList_e) /* epsilon */
				   	;

Statement ::= (MatchedStat) MatchedStatement
			  |
			  (UnmatchedStat) UnmatchedStatement
			  ;
			   
MatchedStatement ::=  (DesignStatement) DesignatorStatement SEMI
					  |
					  (IfElseStatement) IF LPAREN Condition RPAREN MatchedStatement ELSE MatchedStatement
					  |
					  (BreakStatement) BREAK SEMI
					  |
					  (ContinueStatement) CONTINUE SEMI
					  |
					  (ReturnStatement_expr) RETURN Expr SEMI
					  |
					  (ReturnStatement_noexpr) RETURN SEMI
					  |
					  (ReadStatement) READ LPAREN Designator RPAREN SEMI
					  |
					  (PrintStatement) PRINT LPAREN Expr RPAREN SEMI
					  |
					  (PrintStatement2) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			  		  |
					  (SwitchStatement) SwitchStart LBRACE CaseList RBRACE
					  |
					  (ForStatement) ForStart LPAREN  ForDesignatorStatement SEMI ForCondition SEMI ForDesignatorStatement  RPAREN MatchedStatement
					  |
					  (RecStatement) LBRACE StatementList RBRACE
					  ;

UnmatchedStatement ::= (IfElseStatement_non_else) IF LPAREN Condition RPAREN Statement
					   |
					   (IfElseStatement_else) IF LPAREN Condition RPAREN MatchedStatement ELSE UnmatchedStatement
					   ;

ForStart ::= (ForStart) FOR;

SwitchStart ::= (SwitchStart) SWITCH LPAREN Expr RPAREN;

ForDesignatorStatement ::= (ForDesignatorStatement_for) DesignatorStatement
                           |
						   (ForDesignatorStatement_e) /* epsilon */
						   ; 

ForCondition ::= (ForCondition_for) Condition
				|
				(ForCondition_e) /* epsilon */
				; 

CaseList ::= (CaseList_list) CaseList Case
           | (CaseList_e) /* epsilon */
           ;

Case ::= (Case) CASE NUMBER COL CaseStatements;

CaseStatements ::= (CaseStatements_state) CaseStatements Statement
                    |
				   (CaseStatements_e) /* epsilon */ 
				   ;

ActPars ::= (ActPars_list) ActPars COMMA Expr
            |
			(ActPars_single) Expr
			;

DesignatorStatement ::= (DesignatorStatement_ass) Designator Assignop Expr
						|
						(DesignatorStatement_actpar) Designator LPAREN ActPars RPAREN
						|
						(DesignatorStatement_noactpar) Designator LPAREN RPAREN
						|
						(DesignatorStatement_inc) Designator INC
						|
						(DesignatorStatement_dec) Designator DEC
						|
						(DesignatorStatement_error) error:e 
						{: parser.report_error("Oporavak od greske u DesSttmnt.Linija: "+eleft,null); :}
						;

/* CONDITION */

Condition ::= (ConditionList) Condition OR CondTerm
			  |
			  (SingleCondition) CondTerm	
				;

CondTerm ::= (CondTermList) CondTerm AND CondFact
             |
			 (SingleCondTerm) CondFact
			 ;
			 
CondFact ::= (CondFact_norelop) TermList    /* MOZDA TREBA Expr */
             |
             (CondFact_relop) TermList Relop TermList
             ;

Expr ::= (Expr_notern) TermList
		 |
	     (Expr_tern) TernaryCondition QMARK TernExpr1 COL TernExpr2
		  ;

TernaryCondition ::= (TernaryCondition)Condition;

TernExpr1 ::= (TernExpr1) Expr;

TernExpr2 ::= (TernExpr2) Expr;

TermList ::= (TermList_addop) TermList Addop Term
             |
			 (SingleTerm) Term
			 ;

Term ::= (Term) FactorList;

FactorList ::= (FactorList_mulop) FactorList Mulop Factor
               |
			   (SingleFactor) Factor
			   ;

Factor ::= (Factor) Unary FactorUnar;

Unary ::= 	(Unary_m) MINUS
			|
			(Unary_e) /* epsilon */
			;

FactorUnar ::=  (Factor_des) Designator
				|
				(Factor_methpars) Designator LPAREN ActPars RPAREN
		   		|
				(Factor_methnopars) Designator LPAREN  RPAREN
		   		|
		   		(Factor_n) NUMBER
		   		|
		   		(Factor_c) CHAR
		   		|
		   		(Factor_b) BOOL
		   		|		   
		   		(Factor_new_array) NEW Type LBRACKET Expr RBRACKET
		   		|
		   		(Factor_expr) LPAREN Expr RPAREN
		   		;

Designator ::= (Designator_var) IDENT 
               |
			   (Designator_enum) IDENT DOT IDENT
			   |
			   (Designator_len) IDENT DOT LENGTH
			   |
			   (Designator_elem) DesignatorArrayName LBRACKET Expr RBRACKET
			   ;
			   
DesignatorArrayName ::= (DesignatorArrayName) IDENT;
	
			  
Relop ::= (Relop_eq) EQUAL
          |
		  (Relop_neq) NOTEQUAL
          |
		  (Relop_grt) GRT
          |
		  (Relop_Geq) GRTEQ
          |
		  (Relop_ls) LS
          |
		  (Relop_leq) LSEQ
          ;

Assignop ::= (Assignop) ASSIGN;

Addop ::= (Addop_plus) PLUS | (Addop_minus) MINUS ;

Mulop ::= (Mulop_mul) MUL | (Mulop_div) DIV | (Mulop_mod) MOD;